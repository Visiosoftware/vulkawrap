<!--
Copyright 2016 Rob Clucas 
Distributed under the MIT License
(See accompanying LICENSE.txt)
-->
<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Vulkawrap Documentation: Coding Conventions V1.0</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<!-- Additional javascript for drawing charts. -->
<script type="text/javascript" src="highcharts.js"></script>
<script type="text/javascript" src="highcharts-data.js"></script>
<script type="text/javascript" src="highcharts-exporting.js"></script>
<script type="text/javascript" src="chart.js"></script>
<script type="text/javascript" src="hana.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Vulkawrap_logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Vulkawrap Documentation
   </div>
   <div id="projectbrief">Vulkawrap Development Documentation</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('visiosoft-cc.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Coding Conventions V1.0 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#visiosoft-cc-language">Languages</a></li>
<li class="level1"><a href="#visiosoft-cc-compilers">Compilers</a></li>
<li class="level1"><a href="#visiosoft-cc-form">Code Structure</a><ul><li class="level2"><a href="#surge-cc-struct-width">Code Width</a></li>
<li class="level2"><a href="#visiosoft-cc-struct-tabs">Use of Spaces and Tabs</a></li>
</ul>
</li>
<li class="level1"><a href="#visiosoft-cc-files">Files</a><ul><li class="level2"><a href="#visiosoft-cc-files-nameinc">File Naming and Including</a></li>
<li class="level2"><a href="#visiosoft-cc-files-define">The Define Guard</a></li>
</ul>
</li>
<li class="level1"><a href="#visiosoft-cc-comm">Comments</a><ul><li class="level2"><a href="#visiosoft-cc-form-comm-gen">General</a></li>
<li class="level2"><a href="#visiosoft-cc-comm-hsrcfiles">Header/Source Files</a></li>
<li class="level2"><a href="#visiosoft-cc-comm-class">Classes and Structs</a></li>
<li class="level2"><a href="#visiosoft-cc-comm-method">Methods</a></li>
<li class="level2"><a href="#visiosoft-cc-comm-todo">TODO</a></li>
</ul>
</li>
<li class="level1"><a href="#visiosoft-cc-lcomp">Language and Compiler</a><ul><li class="level2"><a href="#visiosoft-cc-lcomp-warn">Warnings</a></li>
<li class="level2"><a href="#visiosoft-cc-lcomp-excep">Exceptions</a></li>
<li class="level2"><a href="#visiosoft-cc-lcomp-cast">Casting</a></li>
<li class="level2"><a href="#visiosoft-cc-lcomp-fcall">Function Pointers</a></li>
<li class="level2"><a href="#visiosoft-cc-lcomp-cstruct">Class and Struct Keywords</a></li>
<li class="level2"><a href="#visiosoft-cc-lcomp-auto">Auto Keyword</a></li>
</ul>
</li>
<li class="level1"><a href="#visiosoft-cc-style">Code Style</a><ul><li class="level2"><a href="#visiosoft-cc-style-earlyex">Early Exits and Minimal Nesting</a></li>
<li class="level2"><a href="#surge-cc-style-predicate-loops">Predicate Loops</a></li>
<li class="level2"><a href="#visiosoft-cc-style-tdef">Typedef vs Alias</a></li>
<li class="level2"><a href="#visiosoft-cc-style-assert">Assertations</a></li>
<li class="level2"><a href="#visiosoft-cc-style-usingstd">Using namespace std</a></li>
<li class="level2"><a href="#visiosoft-cc-style-endl">Using std::endl</a></li>
<li class="level2"><a href="#visiosoft-cc-style-iteration">Container Iteration</a></li>
<li class="level2"><a href="#visiosoft-cc-style-inline">Inlining</a></li>
<li class="level2"><a href="#visiosoft-cc-style-const">Use of const and constexpr</a></li>
</ul>
</li>
<li class="level1"><a href="#visiosoft-cc-formatting">Formatting</a><ul><li class="level2"><a href="#visiosoft-cc-formatting-spaces">Spaces for Parentheses</a></li>
<li class="level2"><a href="#visiosoft-cc-formatting-classes">Classes and Structs</a></li>
<li class="level2"><a href="#visiosoft-cc-formatting-lambda">Lambda Expressions</a></li>
<li class="level2"><a href="#visiosoft-cc-formatting-nspace">Namespaces</a><ul><li class="level3"><a href="#visiosoft-cc-formatting-nspace-annon">Annonymous/Detail namespaces</a></li>
</ul>
</li>
<li class="level2"><a href="#visiosoft-cc-formatting-pandr">Pointer and References</a></li>
<li class="level2"><a href="#visiosoft-cc-naming">Naming</a></li>
<li class="level2"><a href="#visiosoft-cc-naming-typename">Type Names</a></li>
<li class="level2"><a href="#visiosoft-cc-naming-enums">Enums</a></li>
<li class="level2"><a href="#visiosoft-cc-naming-variables">Variables</a></li>
<li class="level2"><a href="#visiosoft-cc-naming-function">Functions</a></li>
<li class="level2"><a href="#visiosoft-cc-naming-meta">Metafunctions</a><ul><li class="level3"><a href="#visiosoft-cc-naming-namespaces">Namespaces</a></li>
</ul>
</li>
<li class="level2"><a href="#visiosoft-cc-naming-preprocessor">Preprocessor Directives</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><hr/>
 <hr/>
<p> This page describes the coding conventions for Visiosoft software, and are based on the coding conventions of LLVM, Boost and Google.</p>
<p>The conventions are particularly important for a large project, which will be the case if Visiosoft becomes its vision. Additionally, following the conventions should allow developers to collaborate and understand the code more easily.</p>
<p>These conventions aim to increase the readability of code base, as well as making it easier to maintain. They will likely be imperfect, so if you have any suggestions, or would like to be involved with the conventions, contact <a href="@mailto:robjclucas@gmail.com">Rob</a>.</p>
<h1><a class="anchor" id="visiosoft-cc-language"></a>
Languages</h1>
<hr/>
 <hr/>
<p> Most of the code be C++, thus these conventions are based on C++. The aim is that any piece of code be clean, modern, and efficient C++ code. When the choice must be made between performance and clarity for a specific section of code, use your discretion. If you choose performance then add a <em>detailed</em> comment, which thoroughly explains the code and the validation of the less readable high performance implementation.</p>
<p>While this is primarily a C++ code base, Vulkan is a C library. To allow the use of Vulkan to have a more modern C++ feel, a C++ based wrapper is under development. The wrapper aims to allow the same level of flexibility but in through a cleaner interface which simplifies the use of Vulkan. It is preferred that the wrapper be used. where the wrapper does not provide some required functionality, it is preferred that the functionality be added to the wrapper, unless it is definitely a once-off feature, in which case raw Vulkan should be used. Again, provide a comment which justifies the use.</p>
<h1><a class="anchor" id="visiosoft-cc-compilers"></a>
Compilers</h1>
<hr/>
 <hr/>
<p> All code should compile with the following compilers:</p>
<ul>
<li>clang (&gt;= 3.7)</li>
<li>gcc (&gt;= 5.3)</li>
<li>MSVC (&gt;= 14.0)</li>
<li>Android (not at present, but in upcoming versions)</li>
</ul>
<h1><a class="anchor" id="visiosoft-cc-form"></a>
Code Structure</h1>
<hr/>
 <hr/>
 <h2><a class="anchor" id="surge-cc-struct-width"></a>
Code Width</h2>
<hr/>
<p> To allow code to viewed with most terminals and editors without resizing, lines should be at most 80 columns wide.</p>
<h2><a class="anchor" id="visiosoft-cc-struct-tabs"></a>
Use of Spaces and Tabs</h2>
<hr/>
<p> Spaces should be used rather than tabs. This is so that there is consistency across all development environments. If your development environment allows it, you can configure it to replace all tabs with 2 spaces.</p>
<p>Indent to 2 spaces in all cases. This provides more room for functions to fit into the 80 column limit, and requires only a single additional keyboard press compared to using a tab.</p>
<p>There are occasions where the indentation of 2 spaces is not the correct indentation. These cases are documented throughout the rest of the conventions. When these cases appear, then follow what is stated in the more specific instance conventions.</p>
<h1><a class="anchor" id="visiosoft-cc-files"></a>
Files</h1>
<hr/>
 <hr/>
<h2><a class="anchor" id="visiosoft-cc-files-nameinc"></a>
File Naming and Including</h2>
<hr/>
<p> All files should be named with underscores, and should have the name of the class which they define or the general functionality they provide.</p>
<p>If the file specialises some functionality, then name the file with the functionality it specialises, followed by the specialization, and then the word <b>spec</b>. Additionally, if the specialization is of a template class, add the word <b>tspec</b>.</p>
<p>If the file defines an interface, then add the <b>iface</b> at the end of the name.</p>
<p>If the file defines a functor, then add <b>ftor</b> at the end of the name.</p>
<p>The following are examples of file names:</p>
<div class="fragment"><div class="line">context.h                 <span class="comment">// Name of a class file</span></div><div class="line">backend_iface.h           <span class="comment">// Name of an interface file</span></div><div class="line">math_pde_float_spec.cc    <span class="comment">// Name of a specialization file</span></div><div class="line">vector_device_tspec.hpp   <span class="comment">// Name of a template specialization file</span></div><div class="line">sum_ftor_.hpp             <span class="comment">// Name of a functor file</span></div></div><!-- fragment --><p>Files should have the following extensions:</p>
<table class="doxtable">
<tr>
<th>File Extension </th><th>Use  </th></tr>
<tr>
<td>h </td><td>For header files without templates </td></tr>
<tr>
<td>hpp </td><td>For templated classes </td></tr>
<tr>
<td>cc </td><td>For implementations of .h files </td></tr>
<tr>
<td>cl </td><td>For OpenCL kernels </td></tr>
</table>
<p>Include's should directly follow the file comment. Include header files minimally, and where possible, prefer to forward declare. Header files should be included in the following order:</p>
<ul>
<li>Headers local to the module</li>
<li>Headers from Visiosoft</li>
<li>Headers from Vulkan</li>
<li>Headers from the C++ standard libraries</li>
<li>Any other headers from other libraries</li>
</ul>
<p>The first two points above, so any headers which are local to the module or are part of Visiosoft, should be included using "", while all other headers should be included using &lt;&gt;. For example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;visiosoft/module/example_class.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &lt;glm/glm.hpp&gt;</span></div></div><!-- fragment --><h2><a class="anchor" id="visiosoft-cc-files-define"></a>
The Define Guard</h2>
<hr/>
<p> All header files (<code>.h</code> and <code>.hpp</code>) should use <code>#define</code> guards. The guard should start with <b>VISIOSOFT</b>, and then have the path from the "/include/visiosoft" directory until the file's directory, followed by the file name, and should be separated by underscores. Each word should be capitalised. Terminating <code>#endif</code>'s should have a comment with the guard name. For example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef VISIOSOFT_PATH_TO_DIR_FILENAME_HPP</span></div><div class="line"><span class="preprocessor">#define VISIOSOFT_PATH_TO_DIR_FILENAME_HPP</span></div><div class="line"> </div><div class="line">  <span class="comment">// Some code here ...</span></div><div class="line"></div><div class="line"><span class="preprocessor">#endif  // VISIOSOFT_PATH_TO_DIR_FILENAME_HPP</span></div></div><!-- fragment --><p>More specifically, for a file "include/visiosoft/module/example_class.h", the guard would be:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef VISIOSOFT_MODULE_EXAMPLE_CLASS_H</span></div><div class="line"><span class="preprocessor">#define VISIOSOFT_MODULE_EXAMPLE_CLASS_H</span></div><div class="line"> </div><div class="line">  <span class="comment">// Some code here ...</span></div><div class="line"></div><div class="line"><span class="preprocessor">#endif  // VISIOSOFT_MODULE_EXAMPLE_CLASS_H</span></div></div><!-- fragment --><h1><a class="anchor" id="visiosoft-cc-comm"></a>
Comments</h1>
<hr/>
 <hr/>
 <h2><a class="anchor" id="visiosoft-cc-form-comm-gen"></a>
General</h2>
<hr/>
<p> Comments are extremely important for making code simpler to understand, most especially in sections which introduce complexity in exchange for increased performance, and in heavily templated code, which will likely be common because of the performance and generalricity its provides.</p>
<p>Comments should we written using correct English, which means that they should make correct use of punctuation, capitalization, spelling, should end with fullstops etc. All comments should describe <b>what</b> the code aims to do, and <b>why</b> it aims to do so, rather than <b>how</b> it does so &ndash; which should be described by the code if it conforms to the surge conventions. In exceptional circumstances &ndash; when the code may be complex in order to achieve orders of magnitude of additional performance &ndash; it is okay to describe how the code achieves its goal.</p>
<p>Doxygen comments should be included as described below. In all instances, use the <code>//</code> comment (even for multi-line comments, and the <code>///</code> comment for the Doxygen version of the comments.</p>
<p>Comments which span multiple lines should be formatted such that the comment text is justified &ndash; each line of the comment has approximately the same width. If the comment is longer than two lines, then the last line can be shorter than the rest. For example:</p>
<div class="fragment"><div class="line"><span class="comment">// This is an example of a badly formatted multiple line comment because the</span></div><div class="line"><span class="comment">// line lengths differ.</span></div><div class="line"></div><div class="line"><span class="comment">// This is an example of a well formatted comment because the </span></div><div class="line"><span class="comment">// lines have the same length, improving the look of the code.</span></div></div><!-- fragment --><h2><a class="anchor" id="visiosoft-cc-comm-hsrcfiles"></a>
Header/Source Files</h2>
<hr/>
<p> Each file should have a comment as the first line of the file which provides the file's path, its name, and the language specification for Emacs users. The first line comment must start and end with "//----" and "----//", respectively. The Emacs file type specification must be immediately yo the left of the closing "----//". The file should the have "Visiosoft LibraryName" on the 3rd line, where "LibraryName" is the name of the library/module for Visiosoft. The file should then have a license reference, which includes the author's name and the location at which the full license can be found.</p>
<p>Doxygen comments for the file name (using <b>file</b>) and a more detailed description (using <b>brief</b>) should be provided last, at the bottom of the main file comment. The start of the filename and description must be in the same column, and descriptions which span multiple lines must also start in that same column.</p>
<p>An example is far more illustrative than a description, so here is one:</p>
<div class="fragment"><div class="line"><span class="comment">//---- include/visiosoft/vulkawrap/util/error.hpp ---------- -*- C++ -*- ----//</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//                           Visiosoft LibraryName</span></div><div class="line"><span class="comment">//                          </span></div><div class="line"><span class="comment">//                        Copyright (c) 2016 Rob Clucas        </span></div><div class="line"><span class="comment">//                      Distributed under the MIT License</span></div><div class="line"><span class="comment">//                (See accompanying file LICENSE or copy at</span></div><div class="line"><span class="comment">//                    https://opensource.org/licenses/MIT)</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// ========================================================================= //</span></div><div class="line"><span class="comment">//</span><span class="comment"></span></div><div class="line"><span class="comment">/// \file   error.hpp</span></div><div class="line"><span class="comment">/// \brief  Defines error handling functionality for the Visiosoft library. The</span></div><div class="line"><span class="comment">///         error handling functionality can be disabled for production code</span></div><div class="line"><span class="comment">///         where the additional performance is required.</span></div><div class="line"><span class="comment">///</span></div><div class="line"><span class="comment"></span><span class="comment">//---------------------------------------------------------------------------//</span></div></div><!-- fragment --><h2><a class="anchor" id="visiosoft-cc-comm-class"></a>
Classes and Structs</h2>
<hr/>
<p> Classes and structs promote good object oriented design. It is important that their purpose is clearly stated. As such, include a comment block which explains the purpose and usage of the class/struct. A class/struct comment looks as follows (note the use of the DOxygen comment style):</p>
<div class="fragment"><div class="line"><span class="comment">/// The example class is a general base class for all Visiosoft examples.</span></div><div class="line"><span class="comment"></span><span class="comment">/// It is used to define the interface which all examples must follow</span></div><div class="line"><span class="comment"></span><span class="comment">/// so that all examples are consistent and easy to understand.</span></div><div class="line"><span class="comment"></span><span class="comment">///</span></div><div class="line"><span class="comment"></span><span class="comment">/// A more detailed description and example usage may follow, if </span></div><div class="line"><span class="comment"></span><span class="comment">/// appropriate. The example class might be used as follows :</span></div><div class="line"><span class="comment"></span><span class="comment">///</span></div><div class="line"><span class="comment"></span><span class="comment">/// /code </span></div><div class="line"><span class="comment"></span><span class="comment">///   // Short demonstration of the example class</span></div><div class="line"><span class="comment"></span><span class="comment">/// /endcode</span></div><div class="line"><span class="comment"></span><span class="keyword">class </span>Example {</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> demonstrate() = 0;</div><div class="line">  <span class="keyword">virtual</span> ~Example();</div><div class="line">};</div></div><!-- fragment --><h2><a class="anchor" id="visiosoft-cc-comm-method"></a>
Methods</h2>
<hr/>
<p> All class methods, and global functions (used within a namespace which is accessible to the library user) should be thoroughly documented using Doxygen comments.</p>
<p>The pre and post conditions should be tested within the method, and should be self documenting, thus do not require comments.</p>
<p>If there are any cases which may prove tricky for the function, then document these in the function description. Examples might be error checking, a specific input causing undefined behaviour, or if no error handling if provided, specify why this decision is made.</p>
<h2><a class="anchor" id="visiosoft-cc-comm-todo"></a>
TODO</h2>
<hr/>
<p> A <code>TODO</code> comment may be included so that other developers can implement the feature, if, for whatever reason, you might not have been able to do so.</p>
<dl class="section note"><dt>Note</dt><dd>The above does not mean that it is okay to commit incomplete code to the repository. A <code>TODO</code> comment may mention that an additional, but not required, feature would add value to the method or class and could be implemented at some point.</dd></dl>
<h1><a class="anchor" id="visiosoft-cc-lcomp"></a>
Language and Compiler</h1>
<hr/>
 <hr/>
<h2><a class="anchor" id="visiosoft-cc-lcomp-warn"></a>
Warnings</h2>
<hr/>
<p> No Visiosoft code should have warnings in it &ndash; if there are then there is a problem somewhere. The code causing the warning should be fixed immediately.</p>
<p>To enable compiler warning code should be compiled with:</p>
<div class="fragment"><div class="line">-Wall (clang/gcc)</div><div class="line">/Wall (MSVC)</div></div><!-- fragment --><h2><a class="anchor" id="visiosoft-cc-lcomp-excep"></a>
Exceptions</h2>
<hr/>
<p> Exceptions slow down code, but can be extremely useful for debugging and producing code which does not break. All code should have error checking and exception handling, but should provide the option to disable the error handling components of the code (at compile time) when performance is critical.</p>
<dl class="section note"><dt>Note</dt><dd>You can also implement the error checking switch using a macro of some sort, but where possible prefer to provide a more modern C++ solution. If this results in complex code, wrap it in a clean interface.</dd></dl>
<p>TODO: Add example of clean error interface once it is complete.</p>
<h2><a class="anchor" id="visiosoft-cc-lcomp-cast"></a>
Casting</h2>
<hr/>
<p> In C++ code, you should never use C-style casting, and only <b>static_cast&lt;&gt;</b> should really be used. As much as possible, unless there is a <em>very</em> good reason to do so, avoid <b>dynamic_cast&lt;&gt;</b> and <b>const_cast&lt;&gt;</b>. Obviously, in C code, C-style casting is the only option and may be used, but the same principles apply.</p>
<h2><a class="anchor" id="visiosoft-cc-lcomp-fcall"></a>
Function Pointers</h2>
<hr/>
<p> C-style function pointers should not be used:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> funcWithCallback(<span class="keywordtype">int</span> paramOne, <span class="keywordtype">void</span> (*callback)(<span class="keywordtype">int</span> x));</div></div><!-- fragment --><p>C-style function pointers provides less opportunity for the compiler to perform optimisation, and the code is less readable. Rather use a C++ functor, and put the implementation of the functor(s) in the header file of the function which uses the functor, if the functor provides functionality related to the module, or in its own file, which follows the naming conventions for functors, if it provides more general functionality:</p>
<div class="fragment"><div class="line"><span class="comment">// file_using_func_with_callback.hpp</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/// Functor to provide some callback functionality on callback.</span></div><div class="line"><span class="comment"></span><span class="keyword">struct </span>SomeCallback {</div><div class="line">  <span class="keywordtype">void</span> operator()(<span class="keywordtype">int</span> x) {</div><div class="line">    <span class="comment">// Some functionality ...</span></div><div class="line">  }</div><div class="line">};</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/// Functor to provid some other callback functionality on callback.</span></div><div class="line"><span class="comment"></span><span class="keyword">struct </span>SomeOtherCallback {</div><div class="line">  <span class="keywordtype">void</span> operator()(<span class="keywordtype">int</span> x) {</div><div class="line">    <span class="comment">// Some other functionality ...</span></div><div class="line">  }</div><div class="line">};</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/// Function which calls a callback functor.</span></div><div class="line"><span class="comment"></span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Functor&gt;</div><div class="line"><span class="keywordtype">void</span> funcWithCallback(<span class="keywordtype">int</span> paramOne, Functor callback) {</div><div class="line">  callback(paramOne);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="visiosoft-cc-lcomp-cstruct"></a>
Class and Struct Keywords</h2>
<hr/>
<p> The <code>class</code> and <code>struct</code> keywords should be used based on the following conditions:</p>
<p>Use struct when all variables are public, or the struct is designed as a container class, with no methods to act on the member variables, otherwise use class. Additionally, metaclasses and metafunctions should use <code>struct</code> so that members are public by default.</p>
<h2><a class="anchor" id="visiosoft-cc-lcomp-auto"></a>
Auto Keyword</h2>
<hr/>
<p> The <code>auto</code> keyword can make code much simpler and hence more readable in certain situation. Use the <code>auto</code> keyword where ever you deem it to make the code more readable, and nowhere else. This is especially the case when the type of the object is immediately obvious from the surrounding context. You may also use it <em>within</em> library implementations to simplify template code.</p>
<dl class="section note"><dt>Note</dt><dd>Limit the use auto to simplify template code if the code may be accessible to the library user (is part of the public interface). It is okay to assume that other developers of Visiosoft understand C++ sufficiently to infer the type of heavily templated code from the surrounding context, which justifies the simplification <code>auto</code> provides. The assumption that any user of the Visiosoft interface should not be made, so attempt to limit the use of advanced template programming in the public interface. In some cases, specific functionality in the public interface cannot be achieved without the use of advanced template programming. In this case, provide a short comment and an example within the comment which will allow any user of the public interface to understand the code's purpose.</dd></dl>
<p>When using the <code>auto</code> keyword, be aware of the efficiency in specific cases.</p>
<p>Make sure that when you do not need to copy, you specify <code>const auto&amp;</code> or <code>const auto*</code>. For example:</p>
<div class="fragment"><div class="line"><span class="comment">// When a copy is needed, use the simple form.</span></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> val : container) { </div><div class="line">  val.modify();</div><div class="line">  doSomethingWithCopiedVal(val);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// When a copy is not required.</span></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; val : container) { dontWantToModify(val); }</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; val : container      ) { wantToModify(val);      }</div><div class="line"></div><div class="line"><span class="comment">// When using pointers, make copying explicit.</span></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* val : container) { dontWantToModify(*val); }</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>* val : container      ) { val-&gt;wantToModify();     }</div></div><!-- fragment --><h1><a class="anchor" id="visiosoft-cc-style"></a>
Code Style</h1>
<hr/>
 <hr/>
<h2><a class="anchor" id="visiosoft-cc-style-earlyex"></a>
Early Exits and Minimal Nesting</h2>
<hr/>
<p> Use early exits to terminate functions if preconditions are not met, as well as to make long code executed by passing such conditions more clear. Often multiple conditional checks in the same place require the reader to store a lot of information, and when the code inside the conditions is long and includes further conditions, storing this information is difficult. For example, the following code:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> functionWithMultipleConditions(conditional&amp; condition) {</div><div class="line">  <span class="keywordflow">if</span> (!isCondition1(condition) &amp;&amp; condition.doesSomethingElse()) {</div><div class="line">    <span class="comment">// Long code based on conditions and potentially more conditions ...</span></div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>Might be re-factored into the following:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> functionWithMultipleConditions(conditional&amp; condition) {</div><div class="line">  <span class="keywordflow">if</span> (isCondition1(condition)) {</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (!condition.doesSomethingElse()) </div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line"></div><div class="line">  <span class="comment">// Long code ...</span></div><div class="line">}</div></div><!-- fragment --><p>This is often the case with loops, and again code can be restructured to reduce nesting and remove the requirement of the reader to have to remember which conditions have passed or failed. This makes it easier to understand <em>why</em> the current state is what it is. The following is not ideal code:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; element : elements) {</div><div class="line">  <span class="keywordflow">if</span> (<span class="keyword">auto</span> subElement = element.getSubElement()) {</div><div class="line">    <span class="keyword">auto</span> left  = subElement.getLeftCondition();</div><div class="line">    <span class="keyword">auto</span> right = subElement.getRightCondition();</div><div class="line">    <span class="keywordflow">if</span> (left != right) {</div><div class="line">      <span class="comment">// ...</span></div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>It could rather be re-factored to become more clear.</p>
<p>Good: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; element : elements) {</div><div class="line">  <span class="keyword">auto</span> subElement = element.getSubElement();</div><div class="line">  <span class="keywordflow">if</span> (!subElement) <span class="keywordflow">continue</span>;   <span class="comment">// Go to next iteration</span></div><div class="line"></div><div class="line">  <span class="keyword">auto</span> left  = subElement.getLeftCondition();</div><div class="line">  <span class="keyword">auto</span> right = subElement.getRightCondition();</div><div class="line">  <span class="keywordflow">if</span> (left == right) <span class="keywordflow">continue</span>;  <span class="comment">// Go to next iteration</span></div><div class="line"></div><div class="line">  <span class="comment">// ... </span></div><div class="line">}</div></div><!-- fragment --><p>Which reduces the nesting, and makes each of the checks significantly more clear. Additionally, there are no <code>else</code> statements for which the reader must remember what the corresponding <code>if</code> statement was.</p>
<h2><a class="anchor" id="surge-cc-style-predicate-loops"></a>
Predicate Loops</h2>
<hr/>
<p> It is common to write a loop which does some computation to return a boolean value. It is preferred that such loops are re-factored into a function, which can be <code>static</code>, <code>inline</code> if small. If the function does not provide some general, reusable functionality, it can be placed inside a <code>detail</code> or <code>annonymous</code> namespace near it's use.</p>
<p>For example, this is not ideal:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> foundFoo = <span class="keyword">false</span>;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; someArray.size(); ++i) {</div><div class="line">  <span class="keywordflow">if</span> (someArray[i].isFoo()) {</div><div class="line">    foundFoo = <span class="keyword">true</span>;</div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line">  } </div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (foundFoo) {</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  }</div><div class="line">  <span class="comment">// ...</span></div><div class="line">} </div></div><!-- fragment --><p>Which can rather be rewritten as a function to compute the predicate, something like:</p>
<div class="fragment"><div class="line"><span class="comment">/// Returns true if a foo element is found in</span></div><div class="line"><span class="comment"></span><span class="comment">/// a some array, otherwise returns false.</span></div><div class="line"><span class="comment"></span><span class="keyword">static</span> <span class="keywordtype">bool</span> containsFoo(<span class="keyword">const</span> std::array&lt;SomeType&gt;&amp; someArray) {</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; someArray.size(); ++i) {</div><div class="line">    <span class="keywordflow">if</span> (someArray[i].isFoo()) {</div><div class="line">      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// It is immediately obvious what is happening here.</span></div><div class="line"><span class="keywordflow">if</span> (containsFoo(someArray)) {</div><div class="line">  <span class="comment">// ... </span></div><div class="line">}</div></div><!-- fragment --><p>This has numerous benefits:</p>
<ul>
<li>Indentation is reduced (in the resulting code which calls the predicate function), which is always ideal as it requires less context to be remembered.</li>
<li>It requires the function to be named, making its purpose clearer, and the resulting code simpler to understand. Additionally, a comment must be written for the function. While this may not be beneficial in this simple example, if the computation is complex or unusual there is huge benefit.</li>
<li>The purpose of the code can be understood from just the name of the function, rather than having to discern the functionality from the inline implementation.</li>
</ul>
<h2><a class="anchor" id="visiosoft-cc-style-tdef"></a>
Typedef vs Alias</h2>
<hr/>
<p>C++11 and later provides the alias feature as an alternative to typedefs. It is preferred that alias's are used rather than typedefs since it encourages modern C++ and the syntax is more clear. Additionally, where an alias is created for a specific template type which may have other similar alias's, then add a suffix to the name which indicates the type (use <code>i</code> for <code>int</code>, use <code>f</code> for <code>float</code> etc).</p>
<p>Here is an example of the preferred use of alias's and typedefs:</p>
<div class="fragment"><div class="line"><span class="comment">// Prefer this</span></div><div class="line"><span class="keyword">using</span> Vec3f = std::array&lt;float, 3&gt;;</div><div class="line"><span class="keyword">using</span> Vec3i = std::array&lt;int, 3&gt;;</div><div class="line"></div><div class="line"><span class="comment">// To this</span></div><div class="line"><span class="keyword">typedef</span> std::array&lt;float, 3&gt; Vec3f;</div><div class="line"><span class="keyword">typedef</span> std::array&lt;int, 3&gt;   Vec3i;</div></div><!-- fragment --><h2><a class="anchor" id="visiosoft-cc-style-assert"></a>
Assertations</h2>
<hr/>
<p> Make use of <code>vs::util::Assert</code> to check preconditions and assumptions. This can often lead to finding bugs that would have otherwise not been found, saving a lot of time when debugging.</p>
<p>Use the Visiosoft <code>vs::util::Assert</code> version of the assert macro as it provides the option for a message describing the reason for the assertation (you should always add a message), adds the line and file where the assertation failed, and can be easily removed at compile time for production code by setting the relevant configuration parameter in the build configuration file for Visiosoft.</p>
<p>Here is an example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;visiosoft/util/assert.hpp&quot;</span></div><div class="line"></div><div class="line">Element getElement(<span class="keywordtype">size_t</span> i) {</div><div class="line">  vs::util::Assert(i &lt; Elements.size(), <span class="stringliteral">&quot;getElement() out of range access!&quot;</span>);</div><div class="line">  <span class="keywordflow">return</span> Elements[i];</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="visiosoft-cc-style-usingstd"></a>
Using namespace std</h2>
<hr/>
<p> Avoid <code>using namespace std</code>, and prefer to use the prefix <code>std::</code>.</p>
<p>Also, in header files, avoid the use of <code>using namespace X</code>, and rather use the prefix <code>X::</code>, since the <code>using</code> directive pollutes the namespace of any source file which includes the header.</p>
<p>In source files this is less of a concern, but should still be applied whenever it is not inconvenient to do so, as it makes functions easy to find. If multiple namespaces are chained, then a <code>using</code> directive can be used to make the code more readable. For example:</p>
<div class="fragment"><div class="line"><span class="comment">// This is a case which can be simplified.</span></div><div class="line">vs::util::math::sum(x, y);</div><div class="line"></div><div class="line"><span class="comment">// To this.</span></div><div class="line"><span class="keyword">namespace </span>vsmath = vs::util::math;</div><div class="line">vsmath::sum(x, y);</div></div><!-- fragment --><p>For this small example this doesn't make much sense as it results in more code, but for cases where many functions are used from the same namespace then this would save typing and most likely result in better formatted and easier to understand code.</p>
<h2><a class="anchor" id="visiosoft-cc-style-endl"></a>
Using std::endl</h2>
<hr/>
<p> The use of <code>std::endl</code> should be avoided, since it flushes the buffer, which is often not required. Rather use <code>\n</code>, and in the case that the output stream must be flushed, then append <code>std::flush</code>, which makes the intention more explicit. For example:</p>
<div class="fragment"><div class="line">std::cout &lt;&lt; std::endl;             <span class="comment">// Avoid this.</span></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;                  <span class="comment">// In favour of this.</span></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span> &lt;&lt; std::flush;    <span class="comment">// Or this to flush the output stream.</span></div></div><!-- fragment --><h2><a class="anchor" id="visiosoft-cc-style-iteration"></a>
Container Iteration</h2>
<p>When iterating over containers and performing some action with the iterator, it is preferred that <code>std::for_each</code> is used, and that the action to perform on the iterator is provided as either a lambda function or as a functor. For example:</p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; elements{1, 2, 3, 4, 5};</div><div class="line"></div><div class="line"><span class="comment">// for_each example with lambda.</span></div><div class="line">std::for_each(elements.begin(), elements.end(), [](<span class="keywordtype">int</span>&amp; n) {</div><div class="line">  n++;</div><div class="line">});</div><div class="line"></div><div class="line"><span class="comment">// for_each example with a functor</span></div><div class="line"><span class="keyword">struct </span>Sum {</div><div class="line">  Sum() : sum_(0) {}</div><div class="line">  <span class="keywordtype">void</span> operator()(<span class="keywordtype">int</span> n) {</div><div class="line">    sum += n;</div><div class="line">  }</div><div class="line">  <span class="keywordtype">int</span> sum;</div><div class="line">};</div><div class="line"></div><div class="line">Sum s = std::for_each(elements.begin(), elements.end(), Sum());</div></div><!-- fragment --><p>However, if the iteration over the container must be written explicitly, then pre-compute the end iterator so that a call to <code>end()</code> or <code>size()</code> is not computed on each iteration.</p>
<dl class="section note"><dt>Note</dt><dd>This doesn't apply to the case where the container is modified by the loop, in which case the pre-computation of <code>end()</code> or <code>size()</code> will produce an incorrect result.</dd></dl>
<p>In the case that the container is modified, add a comment which says so, and states why the container is modified.</p>
<p>Here is an example:</p>
<div class="fragment"><div class="line">IterableArray* array = ...</div><div class="line"></div><div class="line"><span class="comment">// This is the case when the container is not modified:</span></div><div class="line">for (<span class="keyword">auto</span> it = array-&gt;begin(), end = array-&gt;end(); it != end; ++it) {</div><div class="line">  <span class="comment">// Do something with it</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// This is the case when the container is modified (note comment):</span></div><div class="line"><span class="comment">// Modifies the array each time a bar element is found</span></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> it = array-&gt;begin(); it != array-&gt;end(); ++it) {</div><div class="line">  <span class="keywordflow">if</span> (!it-&gt;isBar()) <span class="keywordflow">continue</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Modify array ...</span></div><div class="line">}</div></div><!-- fragment --><p>This is done for the following reasons:</p>
<ul>
<li>For complex types the call to <code>end()</code> can potentially be costly. While this is not the case for a call to <code>size()</code>, the same structure should still be used so that the code is consistent stylistically.</li>
<li>This makes it immediately clear whether or not the container is modified, without even having to look at the implementation of the loop. This is enforced by the requirement of writing a comment for loops which modify the container.</li>
</ul>
<h2><a class="anchor" id="visiosoft-cc-style-inline"></a>
Inlining</h2>
<hr/>
<p> For small functions (approx &lt; 10 lines), the <code>inline</code> keyword may be used to hint to the compiler that it should inline the function. Where a function is inlined implicitly, then avoid the use of the <code>inline</code> keyword. For example:</p>
<div class="fragment"><div class="line"><span class="comment">// Inline is not implicit here, so the inline keyword can be used</span></div><div class="line"><span class="keyword">inline</span> <span class="keywordtype">bool</span> isGreater(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) {</div><div class="line">  <span class="keywordflow">return</span> a &gt; b;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Foo {</div><div class="line">  <span class="comment">// Implicit inline, so don&#39;t use the inline keyword</span></div><div class="line">  <span class="keywordtype">void</span> bar() {</div><div class="line">    <span class="comment">// Some short implementation ...</span></div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><h2><a class="anchor" id="visiosoft-cc-style-const"></a>
Use of const and constexpr</h2>
<hr/>
<p>Make use of <code>const</code> as often as possible, since this allows the compiler to more aggressively optimise. Mark class members <code>const</code> whenever they do not modify class variables.</p>
<p>Use of constexpr is also encouraged, since this allows variables and functions to be computed at compile time, improving performance.</p>
<h1><a class="anchor" id="visiosoft-cc-formatting"></a>
Formatting</h1>
<hr/>
 <hr/>
<h2><a class="anchor" id="visiosoft-cc-formatting-spaces"></a>
Spaces for Parentheses</h2>
<hr/>
<p> A space before an open parentheses is preferred for control-flow statements, but not in function calls or macros. No space is preferred after open parentheses and before closing parentheses, for all cases. For example:</p>
<p>Good: </p><div class="fragment"><div class="line"><span class="comment">// Control flow statements:</span></div><div class="line"><span class="keywordflow">if</span> (A) <span class="comment">// ...</span></div><div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; e; ++i) <span class="comment">// ...</span></div><div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) <span class="comment">//...</span></div><div class="line"></div><div class="line"><span class="comment">// Functions:</span></div><div class="line"><span class="keyword">function</span>(argument);</div><div class="line">SURGE_MACRO(A);</div><div class="line"><span class="keyword">auto</span> x = sum(4, 5) + divide(4, 2);</div></div><!-- fragment --><p>Bad: </p><div class="fragment"><div class="line"><span class="comment">// Control flow statements:</span></div><div class="line"><span class="keywordflow">if</span>(A) <span class="comment">// ...</span></div><div class="line"><span class="keywordflow">for</span>(i = 0; i &lt; e; ++i );</div><div class="line"><span class="keywordflow">for</span>(i=0;i&lt;4;i++);</div><div class="line"><span class="keywordflow">while</span>( <span class="keyword">true</span> );</div><div class="line"></div><div class="line"><span class="comment">// Functions:</span></div><div class="line"><span class="keyword">function</span>( argument );</div><div class="line"><span class="keyword">function</span> (argument);</div><div class="line">SURGE_MACRO ( A );</div><div class="line"><span class="keyword">auto</span> x = sum (4, 5) + divide( 4, 2 );</div></div><!-- fragment --><p>There are some exceptions, when modifications can be made which make the code look better. The main example is when brackets, braces, or function arguments, can be lined up to make nice columns. For example:</p>
<div class="fragment"><div class="line">callToFunctionOne(  arg1, arg2, arg3);</div><div class="line">callToOtherFunction(arg1, arg2      ); </div><div class="line">anotherExample(     arg1, arg2, arg3); </div></div><!-- fragment --><p>Another example is the alignment of variable declarations:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span>       intOne   , intTwo;</div><div class="line"><span class="keywordtype">float</span>     floatOne ;</div><div class="line">OtherType otherType;</div></div><!-- fragment --><h2><a class="anchor" id="visiosoft-cc-formatting-classes"></a>
Classes and Structs</h2>
<hr/>
<p> For classes and structs, the opening brace should be on the same line as the class declaration, and the closing brace should be on its own line.</p>
<p>The <code>public</code>,<code>protected</code> and <code>private</code> keywords should be indented one space. Everything else should be indented two spaces, and variables and aliases should be aligned in columns.</p>
<p>The order of declarations should be as follows:</p>
<ul>
<li>List of friend classes</li>
<li>Public aliases</li>
<li>Public variables</li>
<li>Public methods</li>
<li>Protected aliases</li>
<li>Protected variables</li>
<li>Protected methods</li>
<li>Private aliases</li>
<li>Private variables</li>
<li>Private methods</li>
</ul>
<p>So that the public interface can easily be found at the beginning of the class. Each of the sections within the access specifier should be separated by a space (for example there should be a space between the end of the public aliases and the public variables, etc...).</p>
<p>The following is an example of a correctly formatted class (including correct commenting and naming):</p>
<div class="fragment"><div class="line"><span class="comment">/// Example class illustrating correct class formatting.</span></div><div class="line"><span class="comment"></span><span class="keyword">class </span>ExampleFormatting {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">friend</span> <span class="keyword">class </span>Formatter;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /// Alias for formatting type.</span></div><div class="line"><span class="comment"></span>  <span class="keyword">using</span> FormattingType = SomeFormat;<span class="comment"></span></div><div class="line"><span class="comment">  /// Alias for some other type.</span></div><div class="line"><span class="comment"></span>  <span class="keyword">using</span> SomeOtherType  = SomeType;</div><div class="line"></div><div class="line">  <span class="keywordtype">int</span>    numFormats;        <span class="comment">//!&lt; Number of formats.</span></div><div class="line"><span class="comment"></span>  <span class="keywordtype">float</span>  formatPrecision;   <span class="comment">//!&lt; Precision of a format.</span></div><div class="line"><span class="comment"></span><span class="comment"></span></div><div class="line"><span class="comment">  /// Default constructor.</span></div><div class="line"><span class="comment"></span>  ExampleFormatting() {};</div><div class="line"></div><div class="line"> <span class="keyword">protected</span>:</div><div class="line">  <span class="comment">// ...</span></div><div class="line"></div><div class="line"> <span class="keyword">private</span>:<span class="comment"></span></div><div class="line"><span class="comment">  /// Internal alias for format storage.</span></div><div class="line"><span class="comment"></span>  <span class="keyword">using</span> FormatVector = std::vector&lt;Format&gt;;</div><div class="line"> </div><div class="line">  FormatVector  Formats;    <span class="comment">//!&lt; Storage of the formats.</span></div><div class="line"><span class="comment"></span>  <span class="keywordtype">bool</span>          MustFormat; <span class="comment">//!&lt; If some formatting must be done.</span></div><div class="line"><span class="comment"></span><span class="comment"></span></div><div class="line"><span class="comment">  /// Checks if a format is valid and returns true if</span></div><div class="line"><span class="comment">  /// the format is valid, otherwise returns false.</span></div><div class="line"><span class="comment">  ///</span></div><div class="line"><span class="comment">  /// \param index The index of the format to check the validity of.</span></div><div class="line"><span class="comment"></span>  <span class="keywordtype">bool</span> isValidFormat(<span class="keywordtype">size_t</span> index) <span class="keyword">const</span>;</div><div class="line">};</div></div><!-- fragment --><p>For constructors, the initialization of member variables should be on the same line as the constructor declaration, if they can fit, otherwise they should start on the next line with the colon indented the same amount as the start of the function declaration and the initialization indented 4 spaces. The 4 space indent is so that the initialization stands out from the implementation which uses a 2 space indent. For example:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ExampleClass {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="comment">// Initialization can fit on the same line </span></div><div class="line">  ExampleClass(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) : A(a), B(b) {}</div><div class="line"></div><div class="line">  <span class="comment">// Initialization for inline implementation.</span></div><div class="line">  ExampleClass(SomeComplexType s, <span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b)</div><div class="line">  :    S(s), A(a), B(b) {</div><div class="line">    <span class="comment">// 2 space indentation for the implementation</span></div><div class="line">    someInitilizationFunction();</div><div class="line">  }</div><div class="line"></div><div class="line">  ExampleClass(SomeComplexType s, SomeOtherComplexType sc, <span class="keywordtype">int</span> a);</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  SomeComplextType      S;</div><div class="line">  SomeOtherComplexType  SC;</div><div class="line">  <span class="keywordtype">int</span>                   A;</div><div class="line">  <span class="keywordtype">int</span>                   B;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Initialization for implementation not inline.</span></div><div class="line">ExampleClass::ExampleClass(SomeComplexType s, SomeOtherComplexType sc, <span class="keywordtype">int</span> a) {</div><div class="line">:    S(s), SC(sc), A(a), B(b) {</div><div class="line">  <span class="comment">// Rest of implementation ...</span></div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="visiosoft-cc-formatting-lambda"></a>
Lambda Expressions</h2>
<hr/>
<p> For lambda expressions, the opening brace should be on the same line as the lambda, the closing curly brace } should be on its own line, followed by the closing round bracket ) (if appropriate) and then the semi-colon. The body of the lambda should be indented 2 spaces further than the line above which declares the lambda. For example:</p>
<div class="fragment"><div class="line">for_each(someVector.begin(), someVector.end(), [] (<span class="keywordtype">int</span>&amp; n) {</div><div class="line">  n++;        <span class="comment">// Two space indent.</span></div><div class="line">});           <span class="comment">// Closing brace and bracket on the same line.</span></div></div><!-- fragment --><p>This reduces vertical space and allows more code to fit into a single screen, allowing whomever is reading the code to gain more context.</p>
<p>In the case where the captures and arguments for the lambda roll over to a new line (past the 80 character limit), the next line must have a four space indent. Use discretion to make the code as readable as possible. For example:</p>
<div class="fragment"><div class="line"><span class="comment">// One option</span></div><div class="line">std::for_each(someVector.begin(), someVector.end(), [&amp;someVariable](</div><div class="line">    <span class="keywordtype">int</span>&amp; n) {</div><div class="line">  n++;      <span class="comment">// Normal two space indent.</span></div><div class="line">  <span class="comment">// Some more ...</span></div><div class="line">});         <span class="comment">// Closing brace and bracket on same line.</span></div><div class="line"></div><div class="line"><span class="comment">// Another option</span></div><div class="line">std::for_each(someVector.begin(), someVector.end(), </div><div class="line">    [&amp;someVariable, someOtherVariable] (<span class="keywordtype">int</span>&amp; n) {</div><div class="line">  n++;      <span class="comment">// Normal two space indent.</span></div><div class="line">  <span class="comment">// Some more...</span></div><div class="line">});         <span class="comment">// Closing brace and bracket on same line.</span></div></div><!-- fragment --><p>When there are multiple successive lambda functions, start each one on a new line, with the <code>[]</code> indented two spaces further than the previous indentation, and the body of the lambda indented two spaces from the <code>[]</code>. Line up the <code>[]</code> brackets from each lambda. If the lambdas are surrounded by opening and closing round brackets (as in the case of a function which takes multiple lambdas), then place the closing ) bracket and the semi-colon which follows on their own line. For example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> someFunctionWithMultpleLambdas(</div><div class="line">  [] (<span class="keywordtype">int</span>&amp; n) {               <span class="comment">// Indented two spaces from previous indentation.</span></div><div class="line">    n++;                      <span class="comment">// Further two space indent.</span></div><div class="line">  }, </div><div class="line">  [captureVariable] () {      <span class="comment">// Lines up with previous lambda.</span></div><div class="line">    <span class="comment">// Do something ...       </span></div><div class="line">  }</div><div class="line">);                            <span class="comment">// Placed on their own line.</span></div></div><!-- fragment --><h2><a class="anchor" id="visiosoft-cc-formatting-nspace"></a>
Namespaces</h2>
<hr/>
<p> Each namespace should be declared on it's own line, with an opening brace on the same line. The end of the namespace should have a closing brace on its own line and a comment <code>// namespace namespace_name</code> to indicate the end of the namespace. This makes it easy to search for the end of a namespace using its name for files which have multiple namespaces. The body of the namespace should not be indented, except for forward declarations which should be indented one space. Where multiple namespaces are defined next to each other, make their opening braces align vertically. For example:</p>
<div class="fragment"><div class="line"><span class="comment">// General namespace formatting example</span></div><div class="line"><span class="keyword">namespace </span>example {</div><div class="line"></div><div class="line"><span class="keyword">class </span>Foo {</div><div class="line">};</div><div class="line"></div><div class="line">}  <span class="comment">// namespace example</span></div><div class="line"></div><div class="line"><span class="comment">// Multiple namespace example</span></div><div class="line"><span class="keyword">namespace </span>some_namespace       {</div><div class="line"><span class="keyword">namespace </span>some_other_namespace {</div><div class="line"></div><div class="line">  <span class="comment">// Some code here ...</span></div><div class="line"> </div><div class="line">} <span class="comment">// namespace some_namespace</span></div><div class="line">} <span class="comment">// namespace some_other_namespace</span></div><div class="line"></div><div class="line"><span class="comment">// Example of forward declaration in namespace</span></div><div class="line"><span class="keyword">namespace </span>declare {</div><div class="line"> <span class="keyword">class </span>Foo;</div><div class="line">}  <span class="comment">// namespace declare</span></div></div><!-- fragment --><h3><a class="anchor" id="visiosoft-cc-formatting-nspace-annon"></a>
Annonymous/Detail namespaces</h3>
<p>Annonymous namespaces are a great feature of C++ as they let the compiler know that the contents of the annonymous namespace are only visible to the current translational unit, which allows the compiler to perform more aggressive optimization. These are essentially the same as <code>static</code> functions in C. In C++, however, annonymous namespaces are more general than <code>static</code> since they can make an entire class private to a translational unit, and this should be their primary use.</p>
<p>When using annonymous namespaces, make them as small as possible, and use them primarily for class declarations. For functions, make the choice between an annonymous namespace and static.</p>
<dl class="section note"><dt>Note</dt><dd>The use of annonymous namespaces is for implementation <code>.cc</code> files. For header files, use a <code>detail</code> namespace as shown below.</dd></dl>
<p>Good: </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>{</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Comparator {</div><div class="line">  Comparator();</div><div class="line">  <span class="keywordtype">bool</span> operator()(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line">}  <span class="comment">// end annonymous namespace</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> otherFunction() {</div><div class="line">  <span class="comment">// ...</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> Comparator::operator()(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b)<span class="keyword"> const </span>{</div><div class="line"> <span class="keywordflow">return</span> a &lt; b;</div><div class="line">}</div></div><!-- fragment --><p>Bad: </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>{</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Comparator {</div><div class="line">  Comparator();</div><div class="line">  <span class="keywordtype">bool</span> operator()(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) <span class="keyword">const</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> otherFunction() {</div><div class="line">  <span class="comment">// ...</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> Comparator::operatpr()(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) <span class="keyword">const</span> {</div><div class="line">  <span class="keywordflow">return</span> a &lt; b;</div><div class="line">}</div><div class="line"></div><div class="line">} <span class="comment">// end annonymous namespace</span></div></div><!-- fragment --><p>There is no need for <code>operator()</code> to be included in the namespace, and for <code>someFunction()</code> it is difficult to tell that it is local to the file in the case that it is in the annonymous namespace.</p>
<p>Anything which needs to be hidden from the public interface but has to be included in the header file for some reason should use a <code>detail</code> namespace. While this is technically still accessible to the public interface through the namespace, it lets the user know that the functionality is not intended to be part of the interface.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>detail {</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> someHelper() {</div><div class="line">  <span class="comment">// ...</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Helper {</div><div class="line">  <span class="comment">// ....</span></div><div class="line">}</div><div class="line"></div><div class="line">} <span class="comment">// namespace detail</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> someFunction() {</div><div class="line">  <span class="comment">// Uses the helper</span></div><div class="line">  detail::Helper helper;</div><div class="line">  helper.init();</div><div class="line"></div><div class="line">  detail::someFunction();</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="visiosoft-cc-formatting-pandr"></a>
Pointer and References</h2>
<hr/>
<p>For pointers are references, attach the <code>*</code> or <code>&amp;</code> operators to the type rather than to the name. Additionally, the preferred use of const for pointers and references is shown below:</p>
<div class="fragment"><div class="line"><span class="comment">// Good for pointers:</span></div><div class="line"><span class="keywordtype">int</span>*              p;      <span class="comment">// Non-const pointer to non-const int.</span></div><div class="line"><span class="keywordtype">int</span>* <span class="keyword">const</span>        p;      <span class="comment">// Const pointer to a non-const int.</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span>*        p;      <span class="comment">// Non-const pointer to const int.</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span>* <span class="keyword">const</span>  p;      <span class="comment">// Const pointer to const int.</span></div><div class="line"></div><div class="line"><span class="comment">// Bad for pointers:</span></div><div class="line"><span class="keywordtype">int</span> <span class="keyword">const</span>*        p;</div><div class="line"><span class="keywordtype">int</span>              *p;</div><div class="line"><span class="keywordtype">int</span> * <span class="keyword">const</span>       p;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span>        *p;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> * <span class="keyword">const</span> p;</div><div class="line"></div><div class="line"><span class="comment">// Good for references:</span></div><div class="line"><span class="keywordtype">int</span>&amp;              r;      <span class="comment">// Non-const int reference.</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span>&amp;        r;      <span class="comment">// Const int reference.</span></div><div class="line"></div><div class="line"><span class="comment">// Bad for references:</span></div><div class="line"><span class="keywordtype">int</span>              &amp;r;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span>        &amp;r;</div><div class="line"><span class="keywordtype">int</span> <span class="keyword">const</span>&amp;        r;</div><div class="line"><span class="keywordtype">int</span> <span class="keyword">const</span>        &amp;r;</div></div><!-- fragment --><h2><a class="anchor" id="visiosoft-cc-naming"></a>
Naming</h2>
<hr/>
 <hr/>
<p>Naming is important as poor naming can cause confusion when trying to understand how code works, and can lead to bugs. Names should be descriptive, allowing the reader to understand the use of a variable/type from it's name. Avoid abbreviations where possible, and conform the capitalization conventions, as they are designed to allow for immediate identification of types, variables, functions, etc..., without having to actually search for that information.</p>
<p>Most importantly, be consistent.</p>
<h2><a class="anchor" id="visiosoft-cc-naming-typename"></a>
Type Names</h2>
<hr/>
<p> Type names, such as classes, structs, typedefs, alias's, and type template parameters, should be nouns, use <em>CamelCase</em>, and start with a capital letter. Enums have additional rules, see <a class="el" href="visiosoft-cc.html#visiosoft-cc-naming-enums">enums</a> for these.</p>
<p>Exceptions to this rule are metafunctions and metaclasses, since they act more like variables and functions they have their own rules, see <a class="el" href="visiosoft-cc.html#visiosoft-cc-naming-meta">metaprogramming naming conventions</a>.</p>
<p>The following are examples:</p>
<p>Classes and structs: </p><div class="fragment"><div class="line"><span class="keyword">class </span>ErrorHandler {};</div><div class="line"><span class="keyword">struct </span>FileProperties {}:</div></div><!-- fragment --><p>Typedefs and alises (preferred): </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> std::array&lt;float, 3&gt; Vec3f;</div><div class="line"><span class="keyword">using</span> FloatArray = std::array&lt;float&gt;;</div></div><!-- fragment --><p>Template type parameters: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IteratorType&gt;</div><div class="line"><span class="keyword">class </span>SmallVector {</div><div class="line">  <span class="comment">// ...</span></div><div class="line">};</div></div><!-- fragment --><h2><a class="anchor" id="visiosoft-cc-naming-enums"></a>
Enums</h2>
<hr/>
<p> Enum declarations are types, so they should follow the formatting of type names by using CamelCase. The contents of the enum should be uppercase, separated by underscores. For enums which are not scoped, add a prefix which is an abbreviation of the enum name. Optionally, you can add a prefix which is an abbreviation of the library name. For example:</p>
<div class="fragment"><div class="line"><span class="comment">// Enum not in class or namespace</span></div><div class="line"><span class="keyword">enum</span> ErrorType {</div><div class="line">  ET_SUCCESS = 0, </div><div class="line">  ET_FAILURE</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Access as </span></div><div class="line">ET_SUCCESS</div><div class="line"></div><div class="line"><span class="comment">// Or (optionally) for Visiosoft enums</span></div><div class="line"><span class="keyword">enum</span> ErrorType {</div><div class="line">  VS_ET_SUCCESS = 0,</div><div class="line">  VS_ET_FAILURE</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Enum in it&#39;s own namespace </span></div><div class="line"><span class="keyword">namespace </span>errcode {</div><div class="line"><span class="keyword">enum</span> ErrorType {</div><div class="line">  ET_SUCCESS = 0, </div><div class="line">  ET_FAILURE</div><div class="line">};</div><div class="line">}  <span class="comment">// namespace error_codes</span></div><div class="line"></div><div class="line"><span class="comment">// access is </span></div><div class="line">errcode::ET_SUCCESS;</div><div class="line"></div><div class="line"><span class="comment">// Scoped enum </span></div><div class="line"><span class="keyword">enum class</span> ErrorType : uint8_t {</div><div class="line">  SUCCESS = 0,</div><div class="line">  FAILURE</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// access is </span></div><div class="line">ErrorType::Success</div></div><!-- fragment --><p>Enums which are used to define constants don't need to have a name:</p>
<div class="fragment"><div class="line"><span class="keyword">enum</span> {</div><div class="line">  CONST_ONE = 21, </div><div class="line">  CONST_TWO = 32</div><div class="line">};</div></div><!-- fragment --><h2><a class="anchor" id="visiosoft-cc-naming-variables"></a>
Variables</h2>
<hr/>
<p> Variables should be nouns, and the name should be written using CamelCase, starting with a lowercase letter. Private member variables, however, should begin with an uppercase letter.</p>
<div class="fragment"><div class="line"><span class="comment">// local variable naming example</span></div><div class="line"><span class="keywordtype">int</span> someInt = 4;</div><div class="line"></div><div class="line"><span class="keyword">class </span>NamingExample {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="comment">// public member naming example</span></div><div class="line">  <span class="keywordtype">int</span> someInt; </div><div class="line"></div><div class="line">  <span class="comment">// function argument naming example</span></div><div class="line">  NamingExample(<span class="keywordtype">int</span> someOtherInt)</div><div class="line">  : someInt(someOtherInt) {}</div><div class="line"> </div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="comment">// private member variable naming example</span></div><div class="line">  <span class="keywordtype">int</span> SomeOtherInt;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Params {</div><div class="line">  <span class="keywordtype">bool</span>    firstInstance;</div><div class="line">  <span class="keywordtype">size_t</span>  maxRecursiveCalls;</div><div class="line">};</div></div><!-- fragment --><h2><a class="anchor" id="visiosoft-cc-naming-function"></a>
Functions</h2>
<p>Function names should be verbs, and use CamelCase, with the first word starting with a lowercase letter &ndash; just like public and local variables. The reason for using the same convention for public and local variables, and functions, is that function calls are easily identifiable from the fact that they need arguments (or empty brackets). Using the same style makes the code look better without making it less readable. Function naming example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span>        containsFoo();</div><div class="line">FileHandle  openFile():</div></div><!-- fragment --><p>When the arguments of a function will exceed the 80 character limit, then there are two options for the layout.</p>
<p><b>Indent:</b> The indent for function arguments depends on if the function is a declaration or if the implementation is included. If the function is a declaration then use a 2 space indent for each new line, and if the function includes its implementation then use a 4 space indent. Examples are included in the more specific sections to follow.</p>
<p>There are two styles which may be used for function layout:</p>
<p><b>Continuous List:</b> The arguments directly follow each other so each new argument does not start on a new line:</p>
<div class="fragment"><div class="line"><span class="comment">// Function declaration: 2 space indent</span></div><div class="line"><span class="keywordtype">int</span> aFunctionWithManyLongArguments(ArgumentTypeOne argOne, </div><div class="line">  ArgumentTypeTwo argTwo, ArgumentTypeThree argThree);</div><div class="line"></div><div class="line"><span class="comment">// Function with implementation: 4 space indent</span></div><div class="line"><span class="keywordtype">int</span> aFunctionWithManyLongArguments(ArgumentTypeOne argOne, </div><div class="line">    ArgumentTypeTwo argTwo, ArgumentTypeThree argThree) { </div><div class="line">  <span class="comment">// Implementation with 2 space indent</span></div><div class="line">};</div></div><!-- fragment --><p><b>New Line List:</b> The arguments are each given their own line, and the first argument start on the line following the function name, with the appropriate 2 or 4 space indent. Each of the argument names must start in the same column, as must the commas. The closing ); goes on its own line for a declaration and the closing ) goes on the same line as the last argument, in the same columns as the commas, when the implementation is included:</p>
<div class="fragment"><div class="line"><span class="comment">// Function declaration: 2 space indent</span></div><div class="line"><span class="keywordtype">int</span> aFunctionWithManyLongArguments(</div><div class="line">  ArgumentTypeOne   argOne  , </div><div class="line">  ArgumentTypeTwo   argTwo  , </div><div class="line">  ArgumentTypeThree argThree</div><div class="line">);</div><div class="line"></div><div class="line"><span class="comment">// Function with implementation: 4 space indent</span></div><div class="line"><span class="keywordtype">int</span> aFunctionWithManyLongArguments(</div><div class="line">    ArgumentTypeOne   argOne  , </div><div class="line">    ArgumentTypeTwo   argTwo  , </div><div class="line">    ArgumentTypeThree argThree) { </div><div class="line">  <span class="comment">// Implementation with 2 space indent</span></div><div class="line">};</div></div><!-- fragment --><h2><a class="anchor" id="visiosoft-cc-naming-meta"></a>
Metafunctions</h2>
<hr/>
<p> While metafunctions are implemented using structs and are therefore types, they do not follow the naming conventions of types. To make them easy to identify, they should be written using lowercase letters and each word should be separated using an underscore. Metafunctions should have a <code>value</code> property to access the result of the metafunction and a <code>type</code> property to access the type if that is the result the metafunction produces. This conforms to the STL. For example:</p>
<div class="fragment"><div class="line"><span class="comment">// Determines if a type has error properties</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct </span>has_error_properties {</div><div class="line">  <span class="keyword">static</span> constexpr <span class="keywordtype">bool</span> value = std:is_base_of&lt;ErrorBase, T&gt;::value;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Transforms ListA to ListB</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ListA, <span class="keyword">typename</span> ListB&gt;</div><div class="line"><span class="keyword">struct </span>transform_list {</div><div class="line">  <span class="keyword">using</span> type = <span class="keyword">typename</span> internal_transform&lt;ListA, ListB&gt;::type;</div><div class="line">};</div></div><!-- fragment --><h3><a class="anchor" id="visiosoft-cc-naming-namespaces"></a>
Namespaces</h3>
<p>Namespace names should be made as short as possible, and should use all lowercase letters. In the odd case that a namesapace name needs multiple words, use an underscore to separate the words. For example:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>error {}</div><div class="line"><span class="keyword">namespace </span>error_code {}</div></div><!-- fragment --><p>Attempt to shorten namespace names where possible, so long as the functionality which the encapsulate it still clear, for example:</p>
<p>Less ideal: </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>error_code{}</div></div><!-- fragment --><p>More ideal: </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>errcode {}</div></div><!-- fragment --><h2><a class="anchor" id="visiosoft-cc-naming-preprocessor"></a>
Preprocessor Directives</h2>
<hr/>
<p> Anything which is related to the preprocessor should use fully uppercase words, and each word should be separated using underscores. Examples include when using the <code>\#define</code> statement and Macros:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define NUM_THREADS 512</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define SOME_MACRO(x) x</span></div></div><!-- fragment --><p>The exception is for macros which are a modification of well known macros. For example the <code>assert</code> macro. In the case that another implementation is provided, then make the first letter uppercase and the rest lowercase. For example:</p>
<p>Common macro: </p><div class="fragment"><div class="line">assert(...)</div></div><!-- fragment --><p>Modified version: </p><div class="fragment"><div class="line"><span class="preprocessor">#define Assert(...)</span></div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!--
Copyright 2016 Rob Cluc
Distributed under the MIT License
(See accompanying LICENSE.txt)
-->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
  </ul>
</div>
</body>
</html>
